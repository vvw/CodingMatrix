<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>What is a vector?</title>
		<link rel="shortcut icon" type="image/x-icon" href="../../../../../KonoMngr/style/icons/konoicn.png">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../../../../KonoMngr/style/konoguides.css" />
		<script src="../../../../../KonoMngr/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
  				TeX: { equationNumbers: { autoNumber: "AMS" } }
			});</script>
		<link rel="stylesheet" href="../../../../../KonoMngr/highlight/styles/googlecode.css">
		<script src="../../../../../KonoMngr/highlight/highlight.pack.js" type="text/javascript"></script>
		<script>hljs.initHighlightingOnLoad();</script>		
	</head>
	
	<body class="kg-content">
		<header>
			<h1>What is a vector?</h1>
		</header>
		
		<article class="subsection">
			<p>A vector is a <em>collection of numbers written as a list</em> (where the order matters). A vector with two elements is call a 2-vector, and in general a vector with <em>n elements</em> is named <em>n-vector</em>.</p>
			<p>For example to refer the set of all 4-vectors over \(\mathbb{R}\) we write \(\mathbb{R}^4\)</p>
			<h2 id="">thinking in vector as functions</h2>
			<p>Think of our 4-vector \([3.14159, 2.718282, -1.0, 2.0]\) as a function where:
			$$\begin{array}{ccl}
			    0 & \longmapsto & 3.14159 \\
			    1 & \longmapsto & 2.718282 \\
			    2 & \longmapsto & -1.0 \\
			    3 & \longmapsto & 2.0
			\end{array}$$
			</p>
			
			<article class="note">A vector most of whose values are zero is called a <em><i>sparse vector</i></em>. And if no more that k os the entries are nonzero, we say the vector is <em><i>k-sparse</i></em></article>
			
		</article>
		
		<article class="subsection">
		    <h1>Pedagogical Vec class</h1>
		    <p>To better understand the concepts behind the Vector idea, we will create a special <code>Vec</code> class in python that allow us to look inside. This Vec class is not intended to production, but simply to pedagogical pourposes.</p>
			<ul>
			    <li>A vector is a function from some domain \(D\) to a field.</li>
			    <li>Can represent such a function in python by a <i>dictionary</i>.</li>
			    <li>It's convenient to define a python class <code>Vec</code> with two instance variables:
			        <ul>
			            <li><code>f</code>, the function represented by a python <i>dictionary</i>,</li>
			            <li><code>D</code>, the domain of the function, represented by a python <i>set</i>.</li>
			        </ul>
			    </li>
			    <li>We adopt the convention in which entries with value zero may be ommited from the dictionary <code>f</code>.</li>
			</ul>
			
			<p>Here is a simplified definition of the <code>Vec</code> class:</p>
			<pre><code>class Vec():
    def __init__(self, domain_labels, dict_function):
        self.D = domain_labels
        self.f = dict_function</code></pre>
        
        <h2 id="">using <code>Vec</code></h2>
        <p>Can assign an instance to a variable:</p>
        <pre><code>v = Vec({'A', 'B', 'C'}, {'A': 1.0})</code></pre>
        <p>and usbsequently acces two the field of <code>v</code>, e.g:</p>
        <pre><code>for d in v.D:
    if d in v.f:
        print d, v.f[d]
    else:
        print d, 0.0

A 1.0
B 0.0
C 0.0</code></pre>

            <h2 id="">the complete vec class</h2>
            <p><a href="media/vec.py" target="_blank">Download it here</a></p>
            <pre><code>def getitem(v,k):
    """
    Return the value of entry d in v.
    Be sure getitem(v,d) returns 0 if d is not represented in v.f.

    >>> v = Vec({'a','b','c', 'd'},{'a':2,'c':1,'d':3})
    >>> v['d']
    3
    >>> v['b']
    0
    """
    return v.f[k] if k in v.f else 0

def setitem(v,k,val):
    """
    Set the element of v with label d to be val.
    setitem(v,d,val) should set the value for key d even if d
    is not previously represented in v.f.

    >>> v = Vec({'a', 'b', 'c'}, {'b':0})
    >>> v['b'] = 5
    >>> v['b']
    5
    >>> v['a'] = 1
    >>> v['a']
    1
    """
    v.f[k] = val

def equal(u,v):
    """
    Return true iff u is equal to v.
    Because of sparse representation, it is not enough to compare dictionaries

    >>> Vec({'a', 'b', 'c'}, {'a':0}) == Vec({'a', 'b', 'c'}, {'b':0})
    True

    Be sure that equal(u, v) check equalities for all keys from u.f and v.f even if
    some keys in u.f do not exist in v.f (or vice versa)

    >>> Vec({'x','y','z'},{'y':1,'x':2}) == Vec({'x','y','z'},{'y':1,'z':0})
    False
    >>> Vec({'a','b','c'}, {'a':0,'c':1}) == Vec({'a','b','c'}, {'a':0,'c':1,'b':4})
    False
    >>> Vec({'a','b','c'}, {'a':0,'c':1,'b':4}) == Vec({'a','b','c'}, {'a':0,'c':1})
    False

    The keys matter:
    >>> Vec({'a','b'},{'a':1}) == Vec({'a','b'},{'b':1})
    False

    The values matter:
    >>> Vec({'a','b'},{'a':1}) == Vec({'a','b'},{'a':2})
    False

    """
    assert u.D == v.D
    intersec = set(u.f.keys()) & set(v.f.keys())
    for key in intersec:
        if u.f[key] != v.f[key]:
            return False
    for key in set(u.f.keys()) - intersec:
        if u.f[key] != 0:
            return False
    for key in set(v.f.keys()) - intersec:
        if v.f[key] != 0:
            return False
    return True

def add(u,v):
    """
    Returns the sum of the two vectors.
    Make sure to add together values for all keys from u.f and v.f even if some keys in u.f do not
    exist in v.f (or vice versa)

    >>> a = Vec({'a','e','i','o','u'}, {'a':0,'e':1,'i':2})
    >>> b = Vec({'a','e','i','o','u'}, {'o':4,'u':7})
    >>> c = Vec({'a','e','i','o','u'}, {'a':0,'e':1,'i':2,'o':4,'u':7})
    >>> a + b == c
    True
    >>> a == Vec({'a','e','i','o','u'}, {'a':0,'e':1,'i':2})
    True
    >>> b == Vec({'a','e','i','o','u'}, {'o':4,'u':7})
    True
    >>> d = Vec({'x','y','z'}, {'x':2,'y':1})
    >>> e = Vec({'x','y','z'}, {'z':4,'y':-1})
    >>> f = Vec({'x','y','z'}, {'x':2,'y':0,'z':4})
    >>> d + e == f
    True
    >>> b + Vec({'a','e','i','o','u'}, {}) == b
    True
    """
    assert u.D == v.D
    new_dict = u.f.copy()
    for key in v.f:
        new_dict.setdefault(key, 0)
        new_dict[key] += v.f[key]
    return Vec(u.D, new_dict)

def dot(u,v):
    """
    Returns the dot product of the two vectors.

    >>> u1 = Vec({'a','b'}, {'a':1, 'b':2})
    >>> u2 = Vec({'a','b'}, {'b':2, 'a':1})
    >>> u1*u2
    5
    >>> u1 == Vec({'a','b'}, {'a':1, 'b':2})
    True
    >>> u2 == Vec({'a','b'}, {'b':2, 'a':1})
    True
    >>> v1 = Vec({'p','q','r','s'}, {'p':2,'s':3,'q':-1,'r':0})
    >>> v2 = Vec({'p','q','r','s'}, {'p':-2,'r':5})
    >>> v1*v2
    -4
    >>> w1 = Vec({'a','b','c'}, {'a':2,'b':3,'c':4})
    >>> w2 = Vec({'a','b','c'}, {'a':12,'b':8,'c':6})
    >>> w1*w2
    72

    The pairwise products should not be collected in a set before summing
    because a set eliminates duplicates
    >>> v1 = Vec({1, 2}, {1 : 3, 2 : 6})
    >>> v2 = Vec({1, 2}, {1 : 2, 2 : 1})
    >>> v1 * v2
    12
    """
    assert u.D == v.D
    return sum(u.f[key] * v.f[key] for key in set(u.f.keys()) & set(v.f.keys()))

def scalar_mul(v, alpha):
    """
    Returns the scalar-vector product alpha times v.

    >>> zero = Vec({'x','y','z','w'}, {})
    >>> u = Vec({'x','y','z','w'},{'x':1,'y':2,'z':3,'w':4})
    >>> 0*u == zero
    True
    >>> 1*u == u
    True
    >>> 0.5*u == Vec({'x','y','z','w'},{'x':0.5,'y':1,'z':1.5,'w':2})
    True
    >>> u == Vec({'x','y','z','w'},{'x':1,'y':2,'z':3,'w':4})
    True
    """
    if alpha == 0:
        return Vec(v.D, {})
    elif alpha == 1:
        return v
    else:
        return Vec(v.D, {k:alpha * v.f[k] for k in v.f})

def neg(v):
    """
    Returns the negation of a vector.

    >>> u = Vec({2,4,6,8},{2:1,4:2,6:3,8:4})
    >>> neg(u)
    Vec({8, 2, 4, 6},{8: -4, 2: -1, 4: -2, 6: -3})
    >>> u == Vec({2,4,6,8},{2:1,4:2,6:3,8:4})
    True
    """
    return Vec(v.D, {k:-v.f[k] for k in v.f})

###############################################################################################################################

class Vec:
    """
    A vector has two fields:
    D - the domain (a set)
    f - a dictionary mapping (some) domain elements to field elements
        elements of D not appearing in f are implicitly mapped to zero
    """
    def __init__(self, labels = set(), function = {}):
        self.D = labels
        self.f = function

    __getitem__ = getitem
    __setitem__ = setitem
    __neg__ = neg
    __rmul__ = scalar_mul #if left arg of * is primitive, assume it's a scalar

    def __mul__(self,other):
        #If other is a vector, returns the dot product of self and other
        if isinstance(other, Vec):
            return dot(self,other)
        else:
            return NotImplemented  #  Will cause other.__rmul__(self) to be invoked

    def __truediv__(self,other):  # Scalar division
        return (1/other)*self

    __add__ = add

    def __radd__(self, other):
        "Hack to allow sum(...) to work with vectors"
        if other == 0:
            return self

    def __sub__(a,b):
        "Returns a vector which is the difference of a and b."
        return a+(-b)

    __eq__ = equal

    def is_almost_zero(self):
        s = 0
        for x in self.f.values():
            if isinstance(x, int) or isinstance(x, float):
                s += x*x
            elif isinstance(x, complex):
                s += x*x.conjugate()
            else: return False
        return s &lt; 1e-20

    def __str__(v):
        "pretty-printing"
        D_list = sorted(v.D, key=repr)
        numdec = 3
        wd = dict([(k,(1+max(len(str(k)), len('{0:.{1}G}'.format(v[k], numdec))))) if isinstance(v[k], int) or isinstance(v[k], float) else (k,(1+max(len(str(k)), len(str(v[k]))))) for k in D_list])
        s1 = ''.join(['{0:>{1}}'.format(str(k),wd[k]) for k in D_list])
        s2 = ''.join(['{0:>{1}.{2}G}'.format(v[k],wd[k],numdec) if isinstance(v[k], int) or isinstance(v[k], float) else '{0:>{1}}'.format(v[k], wd[k]) for k in D_list])
        return "\n" + s1 + "\n" + '-'*sum(wd.values()) +"\n" + s2

    def __hash__(self):
        "Here we pretend Vecs are immutable so we can form sets of them"
        h = hash(frozenset(self.D))
        for k,v in sorted(self.f.items(), key = lambda x:repr(x[0])):
            if v != 0:
                h = hash((h, hash(v)))
        return h

    def __repr__(self):
        return "Vec(" + str(self.D) + "," + str(self.f) + ")"

    def copy(self):
        "Don't make a new copy of the domain D"
        return Vec(self.D, self.f.copy())</code></pre>
		</article>
		
	</body>
</html>	
